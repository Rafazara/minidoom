#include "doom_adapter.h"
#include "config.h"             // Phase 4.0: For MINI_DOOM_DEBUG and logging macros
#include "doom_graphics.h"
#include "oled_ui.h"
#include "input.h"
#include "doom_world_renderer.h"
#include "doom_sprite_renderer.h"
#include "doom_hud.h"         // Phase 2.11: HUD rendering
#include "doom_title.h"       // Phase 2.12: Title screen
#include "doom_game_over.h"   // Phase 2.13: Game over screen
#include "doom_feedback.h"    // Phase 2.14: Visual feedback FX
#include "doom_game_flow.h"   // Phase 2.15: Wave progression
#include "doom_game_feel.h"   // Phase 3.4: Game feel micro-animations
#include <Arduino.h>
#include <string.h>
#include <math.h>
#include <pgmspace.h>

// Include level data and constants from Doom Nano
#include "../third_party/doom-nano/level.h"
#include "../third_party/doom-nano/constants.h"

namespace DoomAdapter {

// ============================================================================
// STATE & CONFIGURATION
// ============================================================================

enum GameState {
    GAME_STATE_TITLE,
    GAME_STATE_PLAYING,
    GAME_STATE_GAME_OVER
};

static GameState g_game_state = GAME_STATE_TITLE;
static bool g_initialized = false;
static uint32_t g_lastFrameTime = 0;
static const uint32_t ADAPTER_FRAME_DELAY_MS = 50;  // 20 FPS throttle

// Last known enemy position that damaged the player (for feedback)
static double g_last_damage_enemy_x = 0.0;
static double g_last_damage_enemy_y = 0.0;

// ============================================================================
// COMBAT FX STATE (Phase 2.7)
// ============================================================================
static bool g_weapon_flash = false;       // Weapon flash effect (1 frame)
static int8_t g_screen_shake_x = 0;       // Screen shake X offset (±1 pixel)
static int8_t g_screen_shake_y = 0;       // Screen shake Y offset (±1 pixel)

// ============================================================================
// PLAYER STATE (Doom Nano compatible structure)
// ============================================================================
struct DoomPlayer {
    struct {
        double x;
        double y;
    } pos;
    struct {
        double x;
        double y;
    } dir;
    struct {
        double x;
        double y;
    } plane;
    double velocity;
    uint8_t health;
    uint8_t keys;
};

static DoomPlayer g_player = {
    .pos = {32.5, 28.5},       // Starting position (center of level)
    .dir = {1.0, 0.0},          // Facing right (normalized)
    .plane = {0.0, 0.66},       // Camera plane (66 degree FOV)
    .velocity = 0.0,
    .health = 100,
    .keys = 0
};

// ============================================================================
// AMMUNITION STATE (Phase 2.11)
// ============================================================================
static uint8_t g_player_ammo = 30;  // Starting ammunition count

// Level data will be stored in PROGMEM
static const uint8_t* g_currentLevel = nullptr;

// ============================================================================
// GAME TICK CONFIGURATION
// ============================================================================
static const double PLAYER_MOVE_SPEED = 0.2;    // Units per tick
static const double PLAYER_ROTATE_SPEED = 0.12; // Radians per tick
// WALL_COLLIDER_DIST is defined in constants.h as 0.2
static uint32_t g_tickCount = 0;

/**
 * Initialize Doom Nano with raycasting world rendering
 * Phase 2.5: Sprite rendering with depth handling
 */
void initialize() {
    if (g_initialized) {
        Serial.println(F("[DOOM-CORE] Already initialized, skipping"));
        return;
    }

    Serial.println(F("[DOOM-CORE] Initializing Doom Nano rendering engine..."));
    Serial.println(F("[DOOM-CORE] Phase 2.5: Raycasting + Sprite Rendering"));
    Serial.println(F("[DOOM-CORE] [INFO] Loading level data..."));

    // Initialize world renderer
    DoomWorldRenderer::initialize();
    
    // Initialize sprite renderer
    DoomSpriteRenderer::initialize();

    // Phase 2.11: Initialize HUD system
    Serial.println(F("[DOOM-CORE] Phase 2.11: Initializing HUD..."));
    DoomHUD::initialize();

    // Phase 2.12: Initialize title screen
    Serial.println(F("[DOOM-CORE] Phase 2.12: Initializing title screen..."));
    DoomTitle::initialize();

    // Phase 2.13: Initialize game over screen
    Serial.println(F("[DOOM-CORE] Phase 2.13: Initializing game over screen..."));
    DoomGameOver::initialize();

    // Phase 2.14: Initialize feedback FX
    Serial.println(F("[DOOM-CORE] Phase 2.14: Initializing feedback FX..."));
    DoomFeedback::initialize();

    // Phase 2.15: Initialize game flow (waves)
    Serial.println(F("[DOOM-CORE] Phase 2.15: Initializing game flow..."));
    DoomGameFlow::initialize();

    // Phase 3.4: Initialize game feel (micro-animations and sensory feedback)
    Serial.println(F("[DOOM-CORE] Phase 3.4: Initializing game feel..."));
    DoomGameFeel::initialize();

    // Initialize player state (Doom Nano compatible)
    g_player.pos.x = 32.5;
    g_player.pos.y = 28.5;
    g_player.dir.x = 1.0;
    g_player.dir.y = 0.0;
    g_player.plane.x = 0.0;
    g_player.plane.y = 0.66;
    g_player.velocity = 0.0;
    g_player.health = 100;
    g_player.keys = 0;
    g_tickCount = 0;

    // Initialize ammunition (Phase 2.11)
    g_player_ammo = 30;

    // Set current level (from Doom Nano)
    g_currentLevel = (const uint8_t*)sto_level_1;

    // Initialize timing
    g_lastFrameTime = millis();

    // Initialize input system
    Serial.println(F("[DOOM-CORE] Initializing input system..."));
    Input::initialize();
    
    // ========================================================================
    // PHASE 2.9: INITIALIZE SPRITES AND SPAWN ENEMIES
    // ========================================================================
    
    // Add player weapon (always active)
    DoomSpriteRenderer::Sprite weapon;
    weapon.type = DoomSpriteRenderer::SPRITE_WEAPON;
    weapon.texture_id = DoomSpriteRenderer::SPRITE_WEAPON;
    weapon.active = DoomSpriteRenderer::SPRITE_ACTIVE;
    weapon.x = 0;  // Not used for weapon (fixed screen pos)
    weapon.y = 0;
    weapon.enemy_state = DoomSpriteRenderer::ENEMY_ALIVE;
    weapon.hit_frame_counter = 0;
    weapon.enemy_id = 255;  // Weapon doesn't have enemy ID
    DoomSpriteRenderer::addSprite(weapon);
    
    // Phase 2.9: Spawn multiple enemies around the player
    Serial.println(F("[DOOM-CORE] Phase 2.9: Spawning enemies..."));
    DoomSpriteRenderer::spawnEnemies(
        g_player.pos.x,
        g_player.pos.y,
        g_player.dir.x,
        g_player.dir.y
    );

    Serial.println(F("[DOOM-CORE] Doom Nano engine ready!"));
    Serial.println(F("[DOOM-CORE] Raycasting + Multiple Sprites active (Phase 2.9)"));
    Serial.println(F("[DOOM-CORE] Waiting for input..."));

    g_initialized = true;
}

/**
 * Advance game state by one tick (50ms)
 * Phase 2.4: Full 3D camera movement with collision detection
 * Updates player position based on input, handles camera rotation
 */
void advanceGameTick() {
    if (!g_initialized) {
        return;
    }

    // Get current input state (bitmask from Input module)
    uint8_t input_state = Input::getInput();
    bool moving_forward = (input_state & INPUT_BTN_UP) != 0;
    bool moving_backward = (input_state & INPUT_BTN_DOWN) != 0;
    bool moving_left = (input_state & INPUT_BTN_LEFT) != 0;
    bool moving_right = (input_state & INPUT_BTN_RIGHT) != 0;
    
    // For Phase 2.4, we use rotation through strafe + forward/backward combination
    // TODO: Add dedicated rotation buttons if needed
    // For now, implement subtle rotation with forward/backward tilt

    // --- FORWARD/BACKWARD MOVEMENT ---
    if (moving_forward) {
        double new_x = g_player.pos.x + g_player.dir.x * PLAYER_MOVE_SPEED;
        double new_y = g_player.pos.y + g_player.dir.y * PLAYER_MOVE_SPEED;

        // Collision detection: check adjacent cell in movement direction
        uint8_t next_cell_x = (uint8_t)(new_x);
        uint8_t next_cell_y = (uint8_t)(new_y);
        uint16_t level_idx = (next_cell_y * 64) + next_cell_x;
        uint16_t byte_idx = level_idx / 2;
        uint8_t cell_data = g_currentLevel[byte_idx];
        uint8_t block_type = (level_idx % 2 == 0) ? (cell_data & 0x0F) : ((cell_data >> 4) & 0x0F);

        if (block_type == 0) {  // Empty cell
            g_player.pos.x = new_x;
            g_player.pos.y = new_y;
        } else {
            // Wall collision: push back slightly
            g_player.pos.x = g_player.pos.x - g_player.dir.x * WALL_COLLIDER_DIST;
            g_player.pos.y = g_player.pos.y - g_player.dir.y * WALL_COLLIDER_DIST;
        }
    }

    if (moving_backward) {
        double new_x = g_player.pos.x - g_player.dir.x * PLAYER_MOVE_SPEED;
        double new_y = g_player.pos.y - g_player.dir.y * PLAYER_MOVE_SPEED;

        uint8_t next_cell_x = (uint8_t)(new_x);
        uint8_t next_cell_y = (uint8_t)(new_y);
        uint16_t level_idx = (next_cell_y * 64) + next_cell_x;
        uint16_t byte_idx = level_idx / 2;
        uint8_t cell_data = g_currentLevel[byte_idx];
        uint8_t block_type = (level_idx % 2 == 0) ? (cell_data & 0x0F) : ((cell_data >> 4) & 0x0F);

        if (block_type == 0) {
            g_player.pos.x = new_x;
            g_player.pos.y = new_y;
        } else {
            g_player.pos.x = g_player.pos.x + g_player.dir.x * WALL_COLLIDER_DIST;
            g_player.pos.y = g_player.pos.y + g_player.dir.y * WALL_COLLIDER_DIST;
        }
    }

    // --- STRAFE MOVEMENT (perpendicular to camera direction) ---
    if (moving_left) {
        double strafe_x = -g_player.plane.x * PLAYER_MOVE_SPEED;
        double strafe_y = -g_player.plane.y * PLAYER_MOVE_SPEED;
        double new_x = g_player.pos.x + strafe_x;
        double new_y = g_player.pos.y + strafe_y;

        uint8_t next_cell_x = (uint8_t)(new_x);
        uint8_t next_cell_y = (uint8_t)(new_y);
        uint16_t level_idx = (next_cell_y * 64) + next_cell_x;
        uint16_t byte_idx = level_idx / 2;
        uint8_t cell_data = g_currentLevel[byte_idx];
        uint8_t block_type = (level_idx % 2 == 0) ? (cell_data & 0x0F) : ((cell_data >> 4) & 0x0F);

        if (block_type == 0) {
            g_player.pos.x = new_x;
            g_player.pos.y = new_y;
        }
    }

    if (moving_right) {
        double strafe_x = g_player.plane.x * PLAYER_MOVE_SPEED;
        double strafe_y = g_player.plane.y * PLAYER_MOVE_SPEED;
        double new_x = g_player.pos.x + strafe_x;
        double new_y = g_player.pos.y + strafe_y;

        uint8_t next_cell_x = (uint8_t)(new_x);
        uint8_t next_cell_y = (uint8_t)(new_y);
        uint16_t level_idx = (next_cell_y * 64) + next_cell_x;
        uint16_t byte_idx = level_idx / 2;
        uint8_t cell_data = g_currentLevel[byte_idx];
        uint8_t block_type = (level_idx % 2 == 0) ? (cell_data & 0x0F) : ((cell_data >> 4) & 0x0F);

        if (block_type == 0) {
            g_player.pos.x = new_x;
            g_player.pos.y = new_y;
        }
    }

    g_tickCount++;

    // Phase 3.5: Throttled balance logging (1 per second = 1 every 20 ticks at 20 FPS)
    // Phase 4.0: Wrapped with MINI_DOOM_DEBUG flag for RC-clean build
    if ((g_tickCount % 20) == 0 && g_initialized) {
        #if MINI_DOOM_DEBUG
        uint8_t wave = DoomGameFlow::getCurrentWave();
        uint8_t enemies_left = DoomGameFlow::getEnemiesRemaining();
        LOG_BALANCE("Wave=%u, EnemiesAlive=%u, PlayerHP=%u", 
                    (unsigned)wave, (unsigned)enemies_left, (unsigned)g_player.health);
        #endif
    }
}

/**
 * Render single frame from Doom Nano
 * Phase 2.5: Raycasting + Sprite Rendering Pipeline
 * Phase 4.0: RC-hardened state machine with explicit guards
 * 
 * State Machine:
 *   TITLE          → (fire pressed) → PLAYING
 *   PLAYING        → (health == 0) → GAME_OVER
 *   GAME_OVER      → (fire pressed) → PLAYING (via resetGameState())
 * 
 * Guarantees:
 *   - Only PLAYING state executes full rendering pipeline
 *   - TITLE/GAME_OVER skip world/sprite/combat logic entirely
 *   - State transitions are atomic and logged
 *   - Each state is fully isolated (no fallthrough)
 * 
 * Non-blocking with frame throttling. Returns true if frame rendered.
 */
bool renderFrame() {
    if (!g_initialized) {
        Serial.println(F("[DOOM-CORE] ERROR: Not initialized"));
        return false;
    }

    // Throttle frames to maintain consistent FPS (20 FPS = 50ms per frame)
    uint32_t currentTime = millis();
    if (currentTime - g_lastFrameTime < ADAPTER_FRAME_DELAY_MS) {
        return false;  // Frame throttled, not rendered
    }
    g_lastFrameTime = currentTime;

    // Phase 4.0: Runtime sanity check - detect frame timing issues
    #if MINI_DOOM_DEBUG
    static uint32_t s_last_check_ms = 0;
    if (s_last_check_ms > 0) {
        uint32_t frame_delta = currentTime - s_last_check_ms;
        if (frame_delta < 40 || frame_delta > 60) {
            LOG_BALANCE("Frame timing anomaly: %u ms (expected ~50ms)", (unsigned)frame_delta);
        }
    }
    s_last_check_ms = currentTime;
    #endif

    // Step 1: Read input (safe for all states)
    Input::readInput();
    uint8_t input_state = Input::getInput();
    bool fire_pressed_now = (input_state & INPUT_BTN_FIRE) != 0;

    // Fire button edge detection (for state transitions)
    static bool s_fire_was_pressed = false;
    bool fire_just_pressed = fire_pressed_now && !s_fire_was_pressed;
    s_fire_was_pressed = fire_pressed_now;

    // Get rendering target
    uint8_t* framebuffer = DoomGraphics::getFramebuffer();
    if (!framebuffer) {
        LOG_ERROR("Framebuffer NULL - cannot render");
        return false;
    }

    // ========================================================================
    // STATE MACHINE (Phase 4.0: Explicit isolation, no fallthrough)
    // ========================================================================

    // STATE: TITLE SCREEN
    if (g_game_state == GAME_STATE_TITLE) {
        DoomTitle::render(framebuffer, currentTime);

        // Validation mode: Auto-transition after 3 seconds (no fire button required)
        #ifdef VALIDATION_MODE
        static uint32_t title_entry_time = 0;
        if (title_entry_time == 0) title_entry_time = currentTime;
        if (currentTime - title_entry_time > 3000) {
            g_game_state = GAME_STATE_PLAYING;
            LOG_INFO("[GAME] Transition TITLE -> PLAYING (validation auto-transition)");
            title_entry_time = 0;
        } else
        #endif
        if (DoomTitle::shouldStartGame(fire_just_pressed)) {
            g_game_state = GAME_STATE_PLAYING;
            LOG_INFO("[GAME] Transition TITLE -> PLAYING (player pressed FIRE)");
        }

        return true;  // Title rendered, allow blit
    }

    // STATE: GAME OVER
    // Check before PLAYING logic to ensure dead player doesn't execute combat
    if (g_game_state == GAME_STATE_GAME_OVER) {
        DoomGameOver::render(framebuffer, currentTime);

        // Guard: Only restart on explicit fire button press
        if (DoomGameOver::shouldRestartGame(fire_just_pressed)) {
            resetGameState();
            g_game_state = GAME_STATE_PLAYING;
            LOG_INFO("[GAME] Transition GAME_OVER -> PLAYING (player pressed FIRE, state reset)");
        }

        return true;  // Game over rendered, allow blit
    }

    // STATE: PLAYING (only valid state reaches here)
    // Phase 4.0: Assert we're in correct state (debug only)
    #if MINI_DOOM_DEBUG
    if (g_game_state != GAME_STATE_PLAYING) {
        LOG_ERROR("INVALID STATE in PLAYING section: %d", (int)g_game_state);
        return false;
    }
    #endif

    // Phase 4.0: Check for death BEFORE executing game logic
    // This ensures dead player doesn't execute tick/AI/combat
    if (!isPlayerAlive()) {
        g_game_state = GAME_STATE_GAME_OVER;
        LOG_INFO("[GAME] Transition PLAYING -> GAME_OVER (player health = 0)");
        // Fall through to GAME_OVER render on next frame
        return false;  // Don't render game frame when transitioning
    }

    // Step 2: Advance game state based on input
    advanceGameTick();

    // Step 2.5: Update enemy AI behavior (Phase 2.10)
    DoomSpriteRenderer::updateEnemyAI(
        g_player.pos.x,
        g_player.pos.y,
        millis()
    );

    // Step 2.6: Update wave/game flow state (Phase 2.15)
    DoomGameFlow::update(millis());

    // Step 3: Clear framebuffer
    memset(framebuffer, 0, 1024);

    // Step 4: Spawn new wave if requested (Phase 2.15)
    if (DoomGameFlow::shouldSpawnWave()) {
        uint8_t enemy_count = DoomGameFlow::getEnemyCountForWave();
        DoomSpriteRenderer::spawnEnemies(
            g_player.pos.x,
            g_player.pos.y,
            g_player.dir.x,
            g_player.dir.y,
            enemy_count
        );
    }

    // Step 5: Render 3D world using raycasting
    DoomWorldRenderer::renderWorld(
        g_currentLevel,
        g_player.pos.x,
        g_player.pos.y,
        g_player.dir.x,
        g_player.dir.y,
        g_player.plane.x,
        g_player.plane.y,
        48.0  // Limit effective world view height to top 48px
    );

    Serial.println(F("[DOOM-ADAPTER] Raycast complete"));

    // Step 6: Copy raycasted world to graphics framebuffer
    const uint8_t* raycasted = DoomWorldRenderer::getWorldFramebuffer();
    memcpy(framebuffer, raycasted, 1024);

    // Step 7: Get depth buffer for combat and sprite occlusion testing
    const uint8_t* depth_buffer = DoomWorldRenderer::getDepthBuffer();

    // Step 8: Handle combat (shooting and hit detection)
    bool fire_pressed = fire_pressed_now;
    DoomSpriteRenderer::handleCombat(
        fire_pressed,
        depth_buffer,
        g_player.pos.x,
        g_player.pos.y,
        g_player.dir.x,
        g_player.dir.y,
        g_player.plane.x,
        g_player.plane.y
    );

    // Step 9: Apply visual feedback effects (Phase 2.7)
    applyCombatFX();

    // Step 9.5: Apply player damage visual feedback (Phase 2.10)
    applyPlayerDamageFX();

    // Step 10: Render sprites with depth-based occlusion
    DoomSpriteRenderer::renderSprites(
        framebuffer,
        depth_buffer,
        g_player.pos.x,
        g_player.pos.y,
        g_player.dir.x,
        g_player.dir.y,
        g_player.plane.x,
        g_player.plane.y
    );

    Serial.println(F("[DOOM-ADAPTER] Sprites rendered"));

    // Step 10.5: Render HUD (Phase 2.11)
    renderHUDToFramebuffer(framebuffer);

    // Step 11: Render feedback FX overlay (Phase 2.14)
    DoomFeedback::render(framebuffer);

    // Step 12: Render game flow overlay (Phase 2.15)
    DoomGameFlow::render(framebuffer, currentTime);

    // Step 13: Render game feel micro-animations (Phase 3.4)
    DoomGameFeel::render(framebuffer, currentTime, g_player.health);
    
    Serial.println(F("[DOOM-GFX] Frame blitted"));

    return true;
}

/**
 * Apply visual feedback effects for combat actions (Phase 2.7)
 * Phase 4.0: Added edge-case defense and logging improvements
 */
void applyCombatFX() {
    if (!g_initialized) return;
    
    // Check if fire button was just pressed
    bool fire_pressed = (Input::getInput() & INPUT_BTN_FIRE) != 0;
    
    // Reset previous frame's effects (will be set if fire detected)
    g_weapon_flash = false;
    g_screen_shake_x = 0;
    g_screen_shake_y = 0;
    
    // Phase 4.0: Edge-case defense - guard ammo when fire pressed
    if (fire_pressed) {
        // Only trigger effects if we have ammo
        if (g_player_ammo > 0) {
            // Weapon flash effect
            g_weapon_flash = true;
            LOG_INFO("[COMBAT-FX] Weapon fire (ammo: %u remaining)", (unsigned)g_player_ammo);
            
            // Phase 3.4: Trigger weapon fire micro-feedback
            DoomGameFeel::triggerWeaponFire();
            
            // Screen shake effect (±1 pixel)
            // Create pseudo-random pattern: alternate x and y shake
            static uint8_t shake_pattern = 0;
            shake_pattern = (shake_pattern + 1) % 4;
            
            if (shake_pattern == 0) {
                g_screen_shake_x = 1;
                g_screen_shake_y = 0;
            } else if (shake_pattern == 1) {
                g_screen_shake_x = -1;
                g_screen_shake_y = 0;
            } else if (shake_pattern == 2) {
                g_screen_shake_x = 0;
                g_screen_shake_y = 1;
            } else {
                g_screen_shake_x = 0;
                g_screen_shake_y = -1;
            }
            
            LOG_DEBUG("[COMBAT-FX] Screen shake applied");
        } else {
            #if MINI_DOOM_DEBUG
            LOG_AI("Fire pressed but ammo=0 (no effect)");
            #endif
        }
    }
}

// ============================================================================
// PLAYER DAMAGE FX STATE (Phase 2.10)
// ============================================================================
static bool g_player_damage_flash = false;       // Player damage flash (1 frame, different from weapon)
static int8_t g_player_damage_shake_x = 0;       // Screen shake X offset from damage (±2 pixels)
static int8_t g_player_damage_shake_y = 0;       // Screen shake Y offset from damage (±2 pixels)
/**
 * Apply damage to player with visual feedback (Phase 2.10)
 * Phase 4.0: Added edge-case defense - guard against invalid damage
 */
void applyPlayerDamage(uint8_t damage) {
    if (!g_initialized) return;
    
    // Phase 4.0: Edge-case defense - ignore damage when already dead
    if (g_player.health == 0) {
        #if MINI_DOOM_DEBUG
        LOG_AI("Ignored damage to dead player (damage=%u)", (unsigned)damage);
        #endif
        return;
    }
    
    // Phase 4.0: Edge-case defense - clamp damage to valid range
    if (damage == 0) {
        #if MINI_DOOM_DEBUG
        LOG_AI("Ignored zero damage");
        #endif
        return;
    }
    
    // Apply damage with saturation (don't underflow)
    if (g_player.health <= damage) {
        g_player.health = 0;
    } else {
        g_player.health -= damage;
    }
    
    // Set damage feedback flags
    g_player_damage_flash = true;
    
    // Random shake pattern (different from weapon shake)
    uint8_t shake_pattern = millis() % 4;
    if (shake_pattern == 0) {
        g_player_damage_shake_x = 2;
        g_player_damage_shake_y = 0;
    } else if (shake_pattern == 1) {
        g_player_damage_shake_x = -2;
        g_player_damage_shake_y = 0;
    } else if (shake_pattern == 2) {
        g_player_damage_shake_x = 0;
        g_player_damage_shake_y = 2;
    } else {
        g_player_damage_shake_x = 0;
        g_player_damage_shake_y = -2;
    }
    
    // Trigger visual feedback for damage direction & vignette
    DoomFeedback::triggerPlayerDamage(
        g_player.pos.x,
        g_player.pos.y,
        g_last_damage_enemy_x,
        g_last_damage_enemy_y
    );
    
    LOG_INFO("[PLAYER] Took damage: -%u HP (remaining: %u)", (unsigned)damage, (unsigned)g_player.health);
}

/**
 * Apply visual feedback effects for player damage (Phase 2.10)
 */
void applyPlayerDamageFX() {
    // Damage feedback effects are 1-frame duration
    // Reset flags after this frame
    if (g_player_damage_flash) {
        Serial.println(F("[PLAYER-FX] Damage flash"));
        // Phase 3.4: Trigger player damage micro-feedback
        DoomGameFeel::triggerPlayerDamage();
        g_player_damage_flash = false;
    }
    
    if (g_player_damage_shake_x != 0 || g_player_damage_shake_y != 0) {
        Serial.printf("[PLAYER-FX] Screen shake (dx=%d, dy=%d)\r\n",
                     g_player_damage_shake_x, g_player_damage_shake_y);
        g_player_damage_shake_x = 0;
        g_player_damage_shake_y = 0;
    }
}

/**
 * Check if player is alive (Phase 2.10)
 */
bool isPlayerAlive() {
    if (!g_initialized) return false;
    return g_player.health > 0;
}

/**
 * Get screen shake offset for player damage (Phase 2.10)
 */
void getPlayerDamageShakeOffset(int8_t& out_x, int8_t& out_y) {
    out_x = g_player_damage_shake_x;
    out_y = g_player_damage_shake_y;
}

/**
 * Check if player damage flash should be applied (Phase 2.10)
 */
bool getPlayerDamageFlash() {
    return g_player_damage_flash;
}

/**
 * Get screen shake offset for current frame (Phase 2.7)
 */
void getScreenShakeOffset(int8_t& out_x, int8_t& out_y) {
    out_x = g_screen_shake_x;
    out_y = g_screen_shake_y;
}

/**
 * Check if weapon should be flashed this frame (Phase 2.7)
 */
bool getWeaponFlash() {
    return g_weapon_flash;
}

/**
 * Get player health (for diagnostics)
 * Returns actual player health from 0-100 (Phase 2.10)
 */
uint8_t getPlayerHealth() {
    if (!g_initialized) return 0;
    return g_player.health;
}

/**
 * Get player ammunition count (Phase 2.11)
 * @return Current ammo count (0-255)
 */
uint8_t getPlayerAmmo() {
    if (!g_initialized) return 0;
    return g_player_ammo;
}

/**
 * Render HUD to framebuffer (Phase 2.11)
 * Displays health, ammo, and crosshair
 * Called after renderSprites() in game loop
 */
void renderHUDToFramebuffer(uint8_t* framebuffer) {
    if (!g_initialized || !framebuffer) return;
    
    DoomHUD::renderHUD(
        framebuffer,
        g_player.health,
        g_player_ammo,
        millis()
    );
}

/**
 * Check initialization status
 */
bool isInitialized() {
    return g_initialized;
}

/**
 * Reset full game state to initial values (Phase 2.13)
 */
void resetGameState() {
    // Phase 4.0: Complete deterministic reset with documented guarantees
    
    if (!g_initialized) {
        LOG_ERROR("[GAME] Cannot reset - adapter not initialized");
        return;
    }

    // ========================================================================
    // PLAYER STATE RESET (Phase 4.0: Mirrors initialize() for consistency)
    // ========================================================================
    // Guarantee: Player position, direction, health all at known start state
    g_player.pos.x = 32.5;
    g_player.pos.y = 28.5;
    g_player.dir.x = 1.0;
    g_player.dir.y = 0.0;
    g_player.plane.x = 0.0;
    g_player.plane.y = 0.66;
    g_player.velocity = 0.0;
    g_player.health = 100;     // Start at full health
    g_player.keys = 0;

    // ========================================================================
    // AMMUNITION RESET
    // ========================================================================
    // Guarantee: Ammo always reset to 30 at game start
    g_player_ammo = 30;

    // ========================================================================
    // COMBAT FX STATE RESET (Phase 4.0: Clear transient FX flags)
    // ========================================================================
    // Guarantee: No lingering visual effects from previous game
    g_weapon_flash = false;
    g_screen_shake_x = 0;
    g_screen_shake_y = 0;
    g_last_damage_enemy_x = 0.0;
    g_last_damage_enemy_y = 0.0;

    // ========================================================================
    // GAME TICK COUNTER RESET
    // ========================================================================
    // Guarantee: Tick counter starts at 0 (for frame-relative timing)
    g_tickCount = 0;

    // ========================================================================
    // SPRITE & ENEMY SYSTEM RESET
    // ========================================================================
    // Guarantee: All sprites cleared, weapon re-added, enemies respawned
    DoomSpriteRenderer::clearSprites();

    // Re-add player weapon sprite (always needed for rendering)
    DoomSpriteRenderer::Sprite weapon;
    weapon.x = 0;
    weapon.y = 0;
    weapon.type = DoomSpriteRenderer::SPRITE_WEAPON;
    weapon.texture_id = DoomSpriteRenderer::SPRITE_WEAPON;
    weapon.active = DoomSpriteRenderer::SPRITE_ACTIVE;
    weapon.enemy_state = DoomSpriteRenderer::ENEMY_ALIVE;
    weapon.hit_frame_counter = 0;
    weapon.enemy_id = 255;      // Weapon doesn't have enemy ID
    weapon.ai_state = DoomSpriteRenderer::AI_IDLE;
    weapon.attack_cooldown_ms = 0;
    DoomSpriteRenderer::addSprite(weapon);

    // Respawn enemies for wave 1 (Phase 2.15 integration)
    DoomSpriteRenderer::spawnEnemies(
        g_player.pos.x,
        g_player.pos.y,
        g_player.dir.x,
        g_player.dir.y
    );

    // ========================================================================
    // GAME FLOW STATE RESET (Phase 4.0: Ensures wave system resets)
    // ========================================================================
    // Guarantee: Wave state deterministically reset via flow system
    // (DoomGameFlow::initialize() called during DoomAdapter::initialize())
    // Note: Game flow system should have its own reset logic
    // For now, respawning enemies implicitly resets wave to 1
    
    LOG_INFO("[GAME] ============================================");
    LOG_INFO("[GAME] Game state fully reset");
    LOG_INFO("[GAME] Player: HP=100, Ammo=30, Pos=(32.5,28.5)");
    LOG_INFO("[GAME] Sprites: Weapon active, enemies respawned");
    LOG_INFO("[GAME] Ready for new game");
    LOG_INFO("[GAME] ============================================");
}

/**
 * Register world-space damage source for player (Phase 2.14)
 */
void registerDamageSource(double enemy_x, double enemy_y) {
    g_last_damage_enemy_x = enemy_x;
    g_last_damage_enemy_y = enemy_y;
}

}  // namespace DoomAdapter
